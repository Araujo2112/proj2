-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.cod_postal
(
    id_cod_postal character varying(10) COLLATE pg_catalog."default" NOT NULL,
    localidade character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT cod_postal_pkey PRIMARY KEY (id_cod_postal)
    );

CREATE TABLE IF NOT EXISTS public.espaco_desportivo
(
    id_espaco integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    capacidade integer NOT NULL,
    disponibilidade boolean NOT NULL,
    lote character varying(50) COLLATE pg_catalog."default",
    preco_hora numeric(10, 2) NOT NULL,
    id_tipo_espaco integer NOT NULL,
    hora_abertura time without time zone NOT NULL DEFAULT '08:00:00'::time without time zone,
    hora_fecho time without time zone NOT NULL DEFAULT '22:00:00'::time without time zone,
    CONSTRAINT espaco_desportivo_pkey PRIMARY KEY (id_espaco)
    );

CREATE TABLE IF NOT EXISTS public.manutencao
(
    id_manu integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    custo double precision NOT NULL,
    descricao character varying(255) COLLATE pg_catalog."default",
    dt_fim date,
    dt_ini date NOT NULL,
    id_espaco integer NOT NULL,
    id_estado integer NOT NULL,
    id_usuario integer NOT NULL,
    CONSTRAINT manutencao_pkey PRIMARY KEY (id_manu)
    );

CREATE TABLE IF NOT EXISTS public.notificacao
(
    id_notificacao integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    data_notificacao date NOT NULL,
    hora_notificacao time(6) without time zone NOT NULL,
    mensagem character varying(255) COLLATE pg_catalog."default" NOT NULL,
    id_usuario integer NOT NULL,
    CONSTRAINT notificacao_pkey PRIMARY KEY (id_notificacao)
    );

CREATE TABLE IF NOT EXISTS public.pagamento
(
    id_pagamento integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    dt_pagamento date,
    id_estado integer NOT NULL,
    id_reserva integer NOT NULL,
    id_tipo_pag integer,
    id_usuario integer NOT NULL,
    CONSTRAINT pagamento_pkey PRIMARY KEY (id_pagamento)
    );

CREATE TABLE IF NOT EXISTS public.relatorio
(
    id serial NOT NULL,
    id_tipo integer NOT NULL,
    data_geracao date NOT NULL,
    data_inicio date NOT NULL,
    data_fim date NOT NULL,
    caminho_pdf text COLLATE pg_catalog."default" NOT NULL,
    descricao character varying(255) COLLATE pg_catalog."default",
    data_criacao date,
    CONSTRAINT relatorio_pkey PRIMARY KEY (id)
    );

CREATE TABLE IF NOT EXISTS public.reserva
(
    id_reserva integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    dt date NOT NULL,
    h_fim time(6) without time zone NOT NULL,
    h_ini time(6) without time zone NOT NULL,
    id_espaco integer NOT NULL,
    id_estado integer NOT NULL,
    id_usuario integer NOT NULL,
    CONSTRAINT reserva_pkey PRIMARY KEY (id_reserva)
    );

CREATE TABLE IF NOT EXISTS public.tipo_espaco_desportivo
(
    id_tipo_espaco integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    tipo character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT tipo_espaco_desportivo_pkey PRIMARY KEY (id_tipo_espaco),
    CONSTRAINT ukgiv34k9pkmheo44dldwatl3hf UNIQUE (tipo)
    );

CREATE TABLE IF NOT EXISTS public.tipo_estado
(
    id_estado integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    estado character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT tipo_estado_pkey PRIMARY KEY (id_estado)
    );

CREATE TABLE IF NOT EXISTS public.tipo_pagamento
(
    id_tipo_pag integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    nome character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT tipo_pagamento_pkey PRIMARY KEY (id_tipo_pag)
    );

CREATE TABLE IF NOT EXISTS public.tipo_relatorio
(
    id_tipo serial NOT NULL,
    nome character varying(50) COLLATE pg_catalog."default" NOT NULL,
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    CONSTRAINT tipo_relatorio_pkey PRIMARY KEY (id_tipo),
    CONSTRAINT tipo_relatorio_nome_key UNIQUE (nome)
    );

CREATE TABLE IF NOT EXISTS public.tipo_usuario
(
    id_tipo_usuario integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    tipo character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT tipo_usuario_pkey PRIMARY KEY (id_tipo_usuario)
    );

CREATE TABLE IF NOT EXISTS public.usuario
(
    id_usuario integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    n_porta integer,
    nif integer NOT NULL,
    nome character varying(100) COLLATE pg_catalog."default" NOT NULL,
    rua character varying(255) COLLATE pg_catalog."default",
    tel character varying(15) COLLATE pg_catalog."default" NOT NULL,
    cod_postal character varying(10) COLLATE pg_catalog."default",
    id_tipo_usuario integer NOT NULL,
    email character varying(255) COLLATE pg_catalog."default",
    password character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT usuario_pkey PRIMARY KEY (id_usuario)
    );

ALTER TABLE IF EXISTS public.espaco_desportivo
    ADD CONSTRAINT fkrhxshomfjpr8gc0toh225er4c FOREIGN KEY (id_tipo_espaco)
    REFERENCES public.tipo_espaco_desportivo (id_tipo_espaco) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.manutencao
    ADD CONSTRAINT fkblm1p4eyipaixy2ngg0ojp4oe FOREIGN KEY (id_usuario)
    REFERENCES public.usuario (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.manutencao
    ADD CONSTRAINT fkeoru3gyx6rss8et78b0amqy08 FOREIGN KEY (id_espaco)
    REFERENCES public.espaco_desportivo (id_espaco) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.manutencao
    ADD CONSTRAINT fkjm52cq80vt4xh9ucfpni6jsf2 FOREIGN KEY (id_estado)
    REFERENCES public.tipo_estado (id_estado) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.notificacao
    ADD CONSTRAINT fklklb6xjbjlatiuvdywow2ig5s FOREIGN KEY (id_usuario)
    REFERENCES public.usuario (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.pagamento
    ADD CONSTRAINT fk7dwd98968t8mha1kghaob7rp6 FOREIGN KEY (id_reserva)
    REFERENCES public.reserva (id_reserva) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.pagamento
    ADD CONSTRAINT fk8ys3vc6mvsccrj79ihe8g3dxf FOREIGN KEY (id_estado)
    REFERENCES public.tipo_estado (id_estado) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.pagamento
    ADD CONSTRAINT fka5nokh8dkcl4xdgw3qtlinbpe FOREIGN KEY (id_tipo_pag)
    REFERENCES public.tipo_pagamento (id_tipo_pag) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.pagamento
    ADD CONSTRAINT fkguy43rh3ymgs1gixuwb4tb833 FOREIGN KEY (id_usuario)
    REFERENCES public.usuario (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.relatorio
    ADD CONSTRAINT relatorio_id_tipo_fkey FOREIGN KEY (id_tipo)
    REFERENCES public.tipo_relatorio (id_tipo) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.reserva
    ADD CONSTRAINT fk8kupwxei806ngwafd13ma0847 FOREIGN KEY (id_estado)
    REFERENCES public.tipo_estado (id_estado) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reserva
    ADD CONSTRAINT fkndwfgdg6kqhjvi1r90k4x7ol2 FOREIGN KEY (id_espaco)
    REFERENCES public.espaco_desportivo (id_espaco) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reserva
    ADD CONSTRAINT fksbrwim47vm17adpuqj3dou9au FOREIGN KEY (id_usuario)
    REFERENCES public.usuario (id_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.usuario
    ADD CONSTRAINT fkh1n330u8y5c4xavy0pgfuaxwq FOREIGN KEY (cod_postal)
    REFERENCES public.cod_postal (id_cod_postal) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.usuario
    ADD CONSTRAINT fkr9xk0brid147iaydo8j47o9p2 FOREIGN KEY (id_tipo_usuario)
    REFERENCES public.tipo_usuario (id_tipo_usuario) MATCH SIMPLE
    ON UPDATE NO ACTION
       ON DELETE NO ACTION;

END;

-------------------------
--Triggers
--------------------------------

CREATE OR REPLACE FUNCTION verificar_manutencao_valida()
RETURNS TRIGGER AS $$
BEGIN
    -- 1. Verificar se data final é anterior à data inicial
    IF NEW.dt_fim < NEW.dt_ini THEN
        RAISE EXCEPTION 'Data final não pode ser anterior à data inicial.';
END IF;

    -- 2. Verificar se existe sobreposição com outra manutenção no mesmo espaço
    IF EXISTS (
        SELECT 1 FROM manutencao m
        WHERE m.id_espaco = NEW.id_espaco
          AND m.id_manu <> NEW.id_manu  -- para permitir update na mesma manutenção
          AND (
            (NEW.dt_ini BETWEEN m.dt_ini AND m.dt_fim)
            OR (NEW.dt_fim BETWEEN m.dt_ini AND m.dt_fim)
            OR (m.dt_ini BETWEEN NEW.dt_ini AND NEW.dt_fim)
          )
    ) THEN
        RAISE EXCEPTION 'Já existe uma manutenção nesse espaço desportivo durante esse período.';
END IF;

RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_verificar_manutencao
    BEFORE INSERT OR UPDATE ON manutencao
                         FOR EACH ROW
                         EXECUTE FUNCTION verificar_manutencao_valida();



--

-- Função para verificar disponibilidade
CREATE OR REPLACE FUNCTION verificar_disponibilidade_reserva()
RETURNS TRIGGER AS $$
BEGIN
    -- Verificar se existe sobreposição de horários para o mesmo espaço e dia
    IF EXISTS (
        SELECT 1
        FROM public.reserva
        WHERE id_espaco = NEW.id_espaco
          AND dt = NEW.dt
          AND (
              (NEW.h_ini >= h_ini AND NEW.h_ini < h_fim) OR
              (NEW.h_fim > h_ini AND NEW.h_fim <= h_fim) OR
              (NEW.h_ini <= h_ini AND NEW.h_fim >= h_fim)
          )
    ) THEN
        RAISE EXCEPTION 'Espaço não está disponível para a data e horário solicitados.';
END IF;

    -- Se não houver conflito, permite a inserção ou atualização
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para verificar disponibilidade antes de inserir ou atualizar
CREATE TRIGGER trigger_verificar_disponibilidade
    BEFORE INSERT OR UPDATE ON public.reserva
                         FOR EACH ROW
                         EXECUTE FUNCTION verificar_disponibilidade_reserva();





----

CREATE OR REPLACE FUNCTION criar_pagamento_associado()
RETURNS trigger AS
$$
BEGIN
INSERT INTO public.pagamento (dt_pagamento, id_estado, id_reserva, id_tipo_pag, id_usuario)
VALUES (NULL, 3, NEW.id_reserva, NEW.id_tipo_pag, NEW.id_usuario);

RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trig_criar_pagamento_associado
    AFTER INSERT ON public.reserva
    FOR EACH ROW
    EXECUTE FUNCTION criar_pagamento_associado();

-----------------------------
-------------------------
--Insert
--------------------------------
----------------------------------


--tipo_estado
INSERT INTO public.tipo_estado (id_estado, estado)
VALUES
    (1, 'Feito'),
    (2, 'Cancelado'),
    (3, 'Em Processo');

-- Tipo de usuário
INSERT INTO public.tipo_usuario (id_tipo_usuario, tipo)
VALUES
    (1, 'admin'),
    (2, 'técnico de manutenção'),
    (3, 'user');

-- Código postal
INSERT INTO public.cod_postal (id_cod_postal, localidade)
VALUES
    (1, '4750-052');

-- Usuários
INSERT INTO public.usuario (nome, tel, nif, cod_postal, id_tipo_usuario, rua, n_porta)
VALUES
    ('Joao Antonio', '+351933456789', 123456789, '1', 1, 'Rua Pereiras', 10),
    ('Carlos Ferreira', '+351911223344', 555444333, '1', 2, 'Rua das Oficinas', 5),
    ('Maria Silva', '+351912345678', 987654321, '1', 3, 'Avenida Central', 20);

-- Tipos de espaço desportivo
INSERT INTO public.tipo_espaco_desportivo (id_tipo_espaco, tipo)
VALUES
    (1, 'Futebol'),
    (2, 'Basquetebol'),
    (3, 'Ténis');

--tipos de pagamento
INSERT INTO public.tipo_pagamento (id_tipo_pag, nome)
VALUES
    (1, 'Cartão de Crédito'),
    (2, 'MB Way');

-- tipos de relatorio
INSERT INTO tipo_relatorio (id, nome)
VALUES
    (1, 'Faturação'),
    (2, 'Utilização');


